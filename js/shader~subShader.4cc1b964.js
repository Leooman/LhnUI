(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["shader~subShader"],{"0c47":function(n,e,t){var o=t("c91c"),i=t("b17e");n.exports=Object.keys||function(n){return o(n,i)}},"0e39":function(n,e,t){var o=t("f1a7"),i=t("37d1"),r=t("332c"),a=t("802e"),c=r("IE_PROTO"),s=Object.prototype;n.exports=a?Object.getPrototypeOf:function(n){return n=i(n),o(n,c)?n[c]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?s:null}},"2df4":function(n,e,t){"use strict";var o=t("6b1d"),i=t("2e3f"),r=t("0e39"),a=t("c1a2"),c=t("fa46"),s=t("5b12"),l=t("b8ba"),d=t("7d53"),f=t("0e93"),v=t("5bb7"),u=t("ff89"),p=u.IteratorPrototype,m=u.BUGGY_SAFARI_ITERATORS,h=d("iterator"),g="keys",x="values",y="entries",b=function(){return this};n.exports=function(n,e,t,d,u,S,w){i(t,e,d);var T,C,R,O=function(n){if(n===u&&A)return A;if(!m&&n in _)return _[n];switch(n){case g:return function(){return new t(this,n)};case x:return function(){return new t(this,n)};case y:return function(){return new t(this,n)}}return function(){return new t(this)}},P=e+" Iterator",M=!1,_=n.prototype,I=_[h]||_["@@iterator"]||u&&_[u],A=!m&&I||O(u),E="Array"==e&&_.entries||I;if(E&&(T=r(E.call(new n)),p!==Object.prototype&&T.next&&(f||r(T)===p||(a?a(T,p):"function"!=typeof T[h]&&s(T,h,b)),c(T,P,!0,!0),f&&(v[P]=b))),u==x&&I&&I.name!==x&&(M=!0,A=function(){return I.call(this)}),f&&!w||_[h]===A||s(_,h,A),v[e]=A,u)if(C={values:O(x),keys:S?A:O(g),entries:O(y)},w)for(R in C)(m||M||!(R in _))&&l(_,R,C[R]);else o({target:e,proto:!0,forced:m||M},C);return C}},"2e3f":function(n,e,t){"use strict";var o=t("ff89").IteratorPrototype,i=t("82e8"),r=t("9618"),a=t("fa46"),c=t("5bb7"),s=function(){return this};n.exports=function(n,e,t){var l=e+" Iterator";return n.prototype=i(o,{next:r(1,t)}),a(n,l,!1,!0),c[l]=s,n}},"3cec":function(n,e,t){var o=t("7d53"),i=o("toStringTag"),r={};r[i]="z",n.exports="[object z]"===String(r)},"4e41":function(n,e,t){var o=t("7d53");e.f=o},5268:function(n,e,t){"use strict";var o=t("3cec"),i=t("da06");n.exports=o?{}.toString:function(){return"[object "+i(this)+"]"}},"5bb7":function(n,e){n.exports={}},"68b8":function(n,e,t){var o=t("6a89");o("iterator")},"6a89":function(n,e,t){var o=t("3e36"),i=t("f1a7"),r=t("4e41"),a=t("abdf").f;n.exports=function(n){var e=o.Symbol||(o.Symbol={});i(e,n)||a(e,n,{value:r.f(n)})}},"802e":function(n,e,t){var o=t("72df");n.exports=!o((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},"82e8":function(n,e,t){var o,i=t("157c"),r=t("b99b"),a=t("b17e"),c=t("d687"),s=t("9324"),l=t("f2bf"),d=t("332c"),f=">",v="<",u="prototype",p="script",m=d("IE_PROTO"),h=function(){},g=function(n){return v+p+f+n+v+"/"+p+f},x=function(n){n.write(g("")),n.close();var e=n.parentWindow.Object;return n=null,e},y=function(){var n,e=l("iframe"),t="java"+p+":";return e.style.display="none",s.appendChild(e),e.src=String(t),n=e.contentWindow.document,n.open(),n.write(g("document.F=Object")),n.close(),n.F},b=function(){try{o=document.domain&&new ActiveXObject("htmlfile")}catch(e){}b=o?x(o):y();var n=a.length;while(n--)delete b[u][a[n]];return b()};c[m]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(h[u]=i(n),t=new h,h[u]=null,t[m]=n):t=b(),void 0===e?t:r(t,e)}},"8d0f":function(n,e,t){"use strict";var o=t("6b1d"),i=t("d4cb"),r=t("f498"),a=t("f1a7"),c=t("7526"),s=t("abdf").f,l=t("b634"),d=r.Symbol;if(i&&"function"==typeof d&&(!("description"in d.prototype)||void 0!==d().description)){var f={},v=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof v?new d(n):void 0===n?d():d(n);return""===n&&(f[e]=!0),e};l(v,d);var u=v.prototype=d.prototype;u.constructor=v;var p=u.toString,m="Symbol(test)"==String(d("test")),h=/^Symbol\((.*)\)[^)]+$/;s(u,"description",{configurable:!0,get:function(){var n=c(this)?this.valueOf():this,e=p.call(n);if(a(f,n))return"";var t=m?e.slice(7,-1):e.replace(h,"$1");return""===t?void 0:t}}),o({global:!0,forced:!0},{Symbol:v})}},"918c":function(n,e,t){var o=t("f498"),i=t("130d"),r=t("9531"),a=t("5b12"),c=t("7d53"),s=c("iterator"),l=c("toStringTag"),d=r.values;for(var f in i){var v=o[f],u=v&&v.prototype;if(u){if(u[s]!==d)try{a(u,s,d)}catch(m){u[s]=d}if(u[l]||a(u,l,f),i[f])for(var p in r)if(u[p]!==r[p])try{a(u,p,r[p])}catch(m){u[p]=r[p]}}}},9324:function(n,e,t){var o=t("5428");n.exports=o("document","documentElement")},9531:function(n,e,t){"use strict";var o=t("378c"),i=t("ed2b"),r=t("5bb7"),a=t("cdcd"),c=t("2df4"),s="Array Iterator",l=a.set,d=a.getterFor(s);n.exports=c(Array,"Array",(function(n,e){l(this,{type:s,target:o(n),index:0,kind:e})}),(function(){var n=d(this),e=n.target,t=n.kind,o=n.index++;return!e||o>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:o,done:!1}:"values"==t?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values"),r.Arguments=r.Array,i("keys"),i("values"),i("entries")},b7fb:function(n,e,t){var o=t("8bb2"),i=t("730c"),r=function(n){return function(e,t){var r,a,c=String(i(e)),s=o(t),l=c.length;return s<0||s>=l?n?"":void 0:(r=c.charCodeAt(s),r<55296||r>56319||s+1===l||(a=c.charCodeAt(s+1))<56320||a>57343?n?c.charAt(s):r:n?c.slice(s,s+2):a-56320+(r-55296<<10)+65536)}};n.exports={codeAt:r(!1),charAt:r(!0)}},b99b:function(n,e,t){var o=t("d4cb"),i=t("abdf"),r=t("157c"),a=t("0c47");n.exports=o?Object.defineProperties:function(n,e){r(n);var t,o=a(e),c=o.length,s=0;while(c>s)i.f(n,t=o[s++],e[t]);return n}},c1a2:function(n,e,t){var o=t("157c"),i=t("f3e4");n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set,n.call(t,[]),e=t instanceof Array}catch(r){}return function(t,r){return o(t),i(r),e?n.call(t,r):t.__proto__=r,t}}():void 0)},d6de:function(n,e,t){"use strict";var o=t("6b1d"),i=t("f498"),r=t("5428"),a=t("0e93"),c=t("d4cb"),s=t("e7a0"),l=t("4db4"),d=t("72df"),f=t("f1a7"),v=t("c6de"),u=t("7526"),p=t("157c"),m=t("37d1"),h=t("378c"),g=t("083f"),x=t("9618"),y=t("82e8"),b=t("0c47"),S=t("65d0"),w=t("ee58"),T=t("2402"),C=t("185a"),R=t("abdf"),O=t("e129"),P=t("5b12"),M=t("b8ba"),_=t("4cdd"),I=t("332c"),A=t("d687"),E=t("1d8a"),z=t("7d53"),k=t("4e41"),F=t("6a89"),D=t("fa46"),H=t("cdcd"),j=t("d054").forEach,N=I("hidden"),L="Symbol",G="prototype",V=z("toPrimitive"),q=H.set,B=H.getterFor(L),U=Object[G],X=i.Symbol,Z=r("JSON","stringify"),W=C.f,K=R.f,Y=w.f,J=O.f,Q=_("symbols"),$=_("op-symbols"),nn=_("string-to-symbol-registry"),en=_("symbol-to-string-registry"),tn=_("wks"),on=i.QObject,rn=!on||!on[G]||!on[G].findChild,an=c&&d((function(){return 7!=y(K({},"a",{get:function(){return K(this,"a",{value:7}).a}})).a}))?function(n,e,t){var o=W(U,e);o&&delete U[e],K(n,e,t),o&&n!==U&&K(U,e,o)}:K,cn=function(n,e){var t=Q[n]=y(X[G]);return q(t,{type:L,tag:n,description:e}),c||(t.description=e),t},sn=l?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof X},ln=function(n,e,t){n===U&&ln($,e,t),p(n);var o=g(e,!0);return p(t),f(Q,o)?(t.enumerable?(f(n,N)&&n[N][o]&&(n[N][o]=!1),t=y(t,{enumerable:x(0,!1)})):(f(n,N)||K(n,N,x(1,{})),n[N][o]=!0),an(n,o,t)):K(n,o,t)},dn=function(n,e){p(n);var t=h(e),o=b(t).concat(mn(t));return j(o,(function(e){c&&!vn.call(t,e)||ln(n,e,t[e])})),n},fn=function(n,e){return void 0===e?y(n):dn(y(n),e)},vn=function(n){var e=g(n,!0),t=J.call(this,e);return!(this===U&&f(Q,e)&&!f($,e))&&(!(t||!f(this,e)||!f(Q,e)||f(this,N)&&this[N][e])||t)},un=function(n,e){var t=h(n),o=g(e,!0);if(t!==U||!f(Q,o)||f($,o)){var i=W(t,o);return!i||!f(Q,o)||f(t,N)&&t[N][o]||(i.enumerable=!0),i}},pn=function(n){var e=Y(h(n)),t=[];return j(e,(function(n){f(Q,n)||f(A,n)||t.push(n)})),t},mn=function(n){var e=n===U,t=Y(e?$:h(n)),o=[];return j(t,(function(n){!f(Q,n)||e&&!f(U,n)||o.push(Q[n])})),o};if(s||(X=function(){if(this instanceof X)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=E(n),t=function(n){this===U&&t.call($,n),f(this,N)&&f(this[N],e)&&(this[N][e]=!1),an(this,e,x(1,n))};return c&&rn&&an(U,e,{configurable:!0,set:t}),cn(e,n)},M(X[G],"toString",(function(){return B(this).tag})),M(X,"withoutSetter",(function(n){return cn(E(n),n)})),O.f=vn,R.f=ln,C.f=un,S.f=w.f=pn,T.f=mn,k.f=function(n){return cn(z(n),n)},c&&(K(X[G],"description",{configurable:!0,get:function(){return B(this).description}}),a||M(U,"propertyIsEnumerable",vn,{unsafe:!0}))),o({global:!0,wrap:!0,forced:!s,sham:!s},{Symbol:X}),j(b(tn),(function(n){F(n)})),o({target:L,stat:!0,forced:!s},{for:function(n){var e=String(n);if(f(nn,e))return nn[e];var t=X(e);return nn[e]=t,en[t]=e,t},keyFor:function(n){if(!sn(n))throw TypeError(n+" is not a symbol");if(f(en,n))return en[n]},useSetter:function(){rn=!0},useSimple:function(){rn=!1}}),o({target:"Object",stat:!0,forced:!s,sham:!c},{create:fn,defineProperty:ln,defineProperties:dn,getOwnPropertyDescriptor:un}),o({target:"Object",stat:!0,forced:!s},{getOwnPropertyNames:pn,getOwnPropertySymbols:mn}),o({target:"Object",stat:!0,forced:d((function(){T.f(1)}))},{getOwnPropertySymbols:function(n){return T.f(m(n))}}),Z){var hn=!s||d((function(){var n=X();return"[null]"!=Z([n])||"{}"!=Z({a:n})||"{}"!=Z(Object(n))}));o({target:"JSON",stat:!0,forced:hn},{stringify:function(n,e,t){var o,i=[n],r=1;while(arguments.length>r)i.push(arguments[r++]);if(o=e,(u(e)||void 0!==n)&&!sn(n))return v(e)||(e=function(n,e){if("function"==typeof o&&(e=o.call(this,n,e)),!sn(e))return e}),i[1]=e,Z.apply(null,i)}})}X[G][V]||P(X[G],V,X[G].valueOf),D(X,L),A[N]=!0},da06:function(n,e,t){var o=t("3cec"),i=t("6a61"),r=t("7d53"),a=r("toStringTag"),c="Arguments"==i(function(){return arguments}()),s=function(n,e){try{return n[e]}catch(t){}};n.exports=o?i:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=s(e=Object(n),a))?t:c?i(e):"Object"==(o=i(e))&&"function"==typeof e.callee?"Arguments":o}},ed2b:function(n,e,t){var o=t("7d53"),i=t("82e8"),r=t("abdf"),a=o("unscopables"),c=Array.prototype;void 0==c[a]&&r.f(c,a,{configurable:!0,value:i(null)}),n.exports=function(n){c[a][n]=!0}},ee58:function(n,e,t){var o=t("378c"),i=t("65d0").f,r={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(n){try{return i(n)}catch(e){return a.slice()}};n.exports.f=function(n){return a&&"[object Window]"==r.call(n)?c(n):i(o(n))}},ef1f:function(n,e,t){var o=t("3cec"),i=t("b8ba"),r=t("5268");o||i(Object.prototype,"toString",r,{unsafe:!0})},f3b8:function(n,e,t){"use strict";var o=t("b7fb").charAt,i=t("cdcd"),r=t("2df4"),a="String Iterator",c=i.set,s=i.getterFor(a);r(String,"String",(function(n){c(this,{type:a,string:String(n),index:0})}),(function(){var n,e=s(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=o(t,i),e.index+=n.length,{value:n,done:!1})}))},f3e4:function(n,e,t){var o=t("7526");n.exports=function(n){if(!o(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},f43f:function(n,e,t){"use strict";t.d(e,"b",(function(){return y})),t.d(e,"a",(function(){return fn}));var o={};t.r(o),t.d(o,"testVertexShader",(function(){return E})),t.d(o,"testFragmentShader",(function(){return z}));var i={};t.r(i),t.d(i,"testVertexShader",(function(){return k})),t.d(i,"testFragmentShader",(function(){return F}));var r={};t.r(r),t.d(r,"testVertexShader",(function(){return D})),t.d(r,"testFragmentShader",(function(){return H}));var a={};t.r(a),t.d(a,"testVertexShader",(function(){return j})),t.d(a,"testFragmentShader",(function(){return N}));var c={};t.r(c),t.d(c,"testVertexShader",(function(){return L})),t.d(c,"testFragmentShader",(function(){return G}));var s={};t.r(s),t.d(s,"testVertexShader",(function(){return V})),t.d(s,"testFragmentShader",(function(){return q}));var l={};t.r(l),t.d(l,"testVertexShader",(function(){return B})),t.d(l,"testFragmentShader",(function(){return U}));var d={};t.r(d),t.d(d,"testVertexShader",(function(){return X})),t.d(d,"testFragmentShader",(function(){return Z}));var f={};t.r(f),t.d(f,"testVertexShader",(function(){return W})),t.d(f,"testFragmentShader",(function(){return K}));var v={};t.r(v),t.d(v,"testVertexShader",(function(){return Y})),t.d(v,"testFragmentShader",(function(){return J}));var u={};t.r(u),t.d(u,"testVertexShader",(function(){return Q})),t.d(u,"testFragmentShader",(function(){return $}));var p={};t.r(p),t.d(p,"testVertexShader",(function(){return nn})),t.d(p,"testFragmentShader",(function(){return en}));var m={};t.r(m),t.d(m,"testVertexShader",(function(){return tn})),t.d(m,"testFragmentShader",(function(){return on}));var h={};t.r(h),t.d(h,"testVertexShader",(function(){return rn})),t.d(h,"testFragmentShader",(function(){return an}));var g={};t.r(g),t.d(g,"testVertexShader",(function(){return cn})),t.d(g,"testFragmentShader",(function(){return sn}));var x={};t.r(x),t.d(x,"testVertexShader",(function(){return ln})),t.d(x,"testFragmentShader",(function(){return dn}));var y={};t.r(y),t.d(y,"testShader",(function(){return o})),t.d(y,"test1Shader",(function(){return i})),t.d(y,"test2Shader",(function(){return r})),t.d(y,"test3Shader",(function(){return a})),t.d(y,"test4Shader",(function(){return c})),t.d(y,"test5Shader",(function(){return s})),t.d(y,"test6Shader",(function(){return l})),t.d(y,"test7Shader",(function(){return d})),t.d(y,"test8Shader",(function(){return f})),t.d(y,"test9Shader",(function(){return v})),t.d(y,"test10Shader",(function(){return u})),t.d(y,"test11Shader",(function(){return p})),t.d(y,"test12Shader",(function(){return m})),t.d(y,"test13Shader",(function(){return h})),t.d(y,"test14Shader",(function(){return g})),t.d(y,"test15Shader",(function(){return x}));var b=t("f522"),S=t("50f2"),w=t("dcee"),T=t("31c1"),C=t("cd61"),R=t("1607"),O=t("8bc7"),P=(t("d6de"),t("8d0f"),t("68b8"),t("2d6d"),t("8f0b"),t("ef1f"),t("f3b8"),t("fa8c"),t("918c"),t("38a5")),M={RendererColor:1410703,RendererAlpha:1,CameraFov:40,CameraNear:1,CameraFar:1e5,AxesHelper:!0,AxesSize:2e5},_=function(n){var e="function"===typeof Symbol&&Symbol.iterator,t=e&&n[e],o=0;if(t)return t.call(n);if(n&&"number"===typeof n.length)return{next:function(){return n&&o>=n.length&&(n=void 0),{value:n&&n[o++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")},I=function(){function n(n,e){void 0===e&&(e={}),this.parentElem=n}return n.prototype.init=function(){this.renderer=this.createRenderer(),this.scene=this.createScene(),this.camera=this.createCamera(),this.clock=new O["c"],M.AxesHelper&&this.createAxesHelper()},n.prototype.createRenderer=function(){var n=new O["v"]({antialias:!0,alpha:!0});return n.setClearColor(M.RendererColor,M.RendererAlpha),n.setSize(this.parentElem.clientWidth,this.parentElem.clientHeight),this.parentElem.appendChild(n.domElement),n},n.prototype.createScene=function(){return new O["p"]},n.prototype.createCamera=function(){var n=new O["m"](M.CameraFov,this.parentElem.clientWidth/this.parentElem.clientHeight,M.CameraNear,M.CameraFar);return n.position.set(0,0,500),n.lookAt(this.scene.position),n},n.prototype.createAxesHelper=function(){this.scene.add(new O["a"](M.AxesSize))},n.prototype.animate=function(){this.animation=requestAnimationFrame(this.animate.bind(this)),this.renderer.render(this.scene,this.camera)},n.prototype.destroy=function(){window.removeEventListener("resize",this.resize),this.clearScene(),this.renderer.renderLists.dispose(),this.renderer.dispose(),this.renderer.forceContextLoss(),cancelAnimationFrame(this.animation),O["b"].clear()},n.prototype.clearScene=function(){this._removeItem(this.scene)},n.prototype._removeItem=function(n){var e=this,t=n.children.filter((function(n){return n}));t.forEach((function(n){n.children.length?e._removeItem(n):(n.geometry.dispose(),n.material.dispose(),n.clear())})),n.clear(),t=null},n.prototype.resize=function(){},n.prototype.registerEventListeners=function(){var n,e,t=this._registerListener();for(var o in t){var i=Array.isArray(t[o])?t[o]:[t[o]];try{for(var r=(n=void 0,_(i)),a=r.next();!a.done;a=r.next()){var c=a.value;this.renderer.domElement.addEventListener(o,c.fn)}}catch(s){n={error:s}}finally{try{a&&!a.done&&(e=r.return)&&e.call(r)}finally{if(n)throw n.error}}}},n.prototype._registerListener=function(){var n,e="object"===Object(P["a"])(window.onmousewheel)?"mousewheel":"DOMMouseScroll";return n={},n[e]={fn:function(n){}},n.pointerup={fn:function(n){}},n.pointermove={fn:function(n){}},n},n}(),A=function(n){Object(S["a"])(t,n);var e=Object(w["a"])(t);function t(n){var o,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Object(b["a"])(this,t),o=e.call(this,n,i),o.parentElem=n,o.shaderMaterial=i.shader,o}return Object(T["a"])(t,[{key:"init",value:function(){Object(C["a"])(Object(R["a"])(t.prototype),"init",this).call(this),this.shader=this.createShader(),this.animate()}},{key:"createShader",value:function(){var n=this.parentElem.clientWidth,e=this.parentElem.clientHeight,t={iTime:{value:1},iResolution:{value:new O["t"](1*n,1*e)},iMouse:{value:new O["u"](0,0,0)}},o=new O["q"]({uniforms:t,vertexShader:this.shaderMaterial.testVertexShader,fragmentShader:this.shaderMaterial.testFragmentShader}),i=new O["n"](n,e),r=new O["h"](i,o);return this.scene.add(r),r}},{key:"animate",value:function(){Object(C["a"])(Object(R["a"])(t.prototype),"animate",this).call(this),this.shader.material.uniforms.iTime.value+=this.clock.getDelta()}}]),t}(I),E="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",z="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    void main()\n    {\n        vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n        float tau = 3.1415926535*2.0;\n        float a = atan(p.x,p.y);\n        float r = length(p)*0.75;\n        vec2 uv = vec2(a/tau,r);\n        \n        //get the color\n        float xCol = (uv.x - (iTime / 3.0)) * 3.0;\n        xCol = mod(xCol, 3.0);\n        vec3 horColour = vec3(0.25, 0.25, 0.25);\n        \n        if (xCol < 1.0) {\n            \n            horColour.r += 1.0 - xCol;\n            horColour.g += xCol;\n        }\n        else if (xCol < 2.0) {\n            \n            xCol -= 1.0;\n            horColour.g += 1.0 - xCol;\n            horColour.b += xCol;\n        }\n        else {\n            \n            xCol -= 2.0;\n            horColour.b += 1.0 - xCol;\n            horColour.r += xCol;\n        }\n\n        // draw color beam\n        uv = (2.0 * uv) - 1.0;\n        float beamWidth = (0.7+0.5*cos(uv.x*10.0*tau*0.15*clamp(floor(5.0 + 10.0*cos(iTime)), 0.0, 10.0))) * abs(1.0 / (30.0 * uv.y));\n        vec3 horBeam = vec3(beamWidth);\n        gl_FragColor = vec4((( horBeam) * horColour), 1.0);\n    }\n",k="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",F="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    #define SC 3.0\n\n    #if 1\n    //\n    // Elegant way to intersect a planar coordinate system (3x3 linear system)\n    //\n    vec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n    {\n        vec3 q = o - c;\n        return vec3(\n            dot( cross(u,v), q ),\n            dot( cross(q,u), d ),\n            dot( cross(v,q), d ) ) / \n            dot( cross(v,u), d );\n    }\n\n    #else\n    //\n    // Ugly (but faster) way to intersect a planar coordinate system: plane + projection\n    //\n    vec3 intersectCoordSys( in vec3 o, in vec3 d, vec3 c, vec3 u, vec3 v )\n    {\n        vec3  q = o - c;\n        vec3  n = cross(u,v);\n        float t = -dot(n,q)/dot(d,n);\n        float r =  dot(u,q + d*t);\n        float s =  dot(v,q + d*t);\n        return vec3(t,s,r);\n    }\n\n    #endif\t\n\n    vec3 hash3( float n )\n    {\n        return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,12578.1459123,19642.3490423));\n    }\n\n    vec3 shade( in vec4 res )\n    {\n        float ra = length(res.yz);\n        float an = atan(res.y,res.z) + 8.0*iTime;\n        float pa = sin(3.0*an);\n\n        vec3 cola = 0.5 + 0.5*sin( (res.w/64.0)*3.5 + vec3(0.0,1.0,2.0) );\n        \n        vec3 col = vec3(0.0);\n        col += cola*0.4*(1.0-smoothstep( 0.90, 1.00, ra) );\n        col += cola*1.0*(1.0-smoothstep( 0.00, 0.03, abs(ra-0.8)))*(0.5+0.5*pa);\n        col += cola*1.0*(1.0-smoothstep( 0.00, 0.20, abs(ra-0.8)))*(0.5+0.5*pa);\n        col += cola*0.5*(1.0-smoothstep( 0.05, 0.10, abs(ra-0.5)))*(0.5+0.5*pa);\n        col += cola*0.7*(1.0-smoothstep( 0.00, 0.30, abs(ra-0.5)))*(0.5+0.5*pa);\n\n        return col*0.3;\n    }\n\n    vec3 render( in vec3 ro, in vec3 rd )\n    {\n        // raytrace\n        vec3 col = vec3( 0.0 );\n        for( int i=0; i<64; i++ )\n        {\n            // position disk\n            vec3 r = 2.5*(-1.0 + 2.0*hash3( float(i) ));\n    r *= SC;\t\t\n            // orientate disk\n            vec3 u = normalize( r.zxy );\n            vec3 v = normalize( cross( u, vec3(0.0,1.0,0.0 ) ) );\t\t\t\t\t\t   \n            \n            // intersect coord sys\n            vec3 tmp = intersectCoordSys( ro, rd, r, u, v );\n    tmp /= SC;\t\t\n            if( dot(tmp.yz,tmp.yz)<1.0 && tmp.x>0.0 ) \n            {\n                // shade\t\t\t\n                col += shade( vec4(tmp,float(i)) );\n            }\n        }\n\n        return col;\n    }\n\n    void main()\n    {\n        vec2 q = gl_FragCoord.xy / iResolution.xy;\n        vec2 p = -1.0 + 2.0 * q;\n        p.x *= iResolution.x/iResolution.y;\n\n        // camera\n        vec3 ro = 2.0*vec3(cos(0.5*iTime*1.1),0.0,sin(0.5*iTime*1.1));\n        vec3 ta = vec3(0.0,0.0,0.0);\n        // camera matrix\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n        vec3 vv = normalize( cross(uu,ww));\n        // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.0*ww );\n\n        vec3 col = render( ro*SC, rd );\n        \n        gl_FragColor = vec4( col, 1.0 );\n    }\n\n    // void mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n    // {\n    //     vec3 col = render( fragRayOri + vec3(0.0,0.0,0.0), fragRayDir );\n\n    //     fragColor = vec4( col, 1.0 );\n    // }\n",D="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",H="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    uniform vec4 iMouse; //shader playback time (in seconds)\n    void main()\n    {\n        float gTime = iTime+11.0;\n\n        float f = 3., g = 3.;\n        vec2 res = iResolution.xy;\n        vec2 mou = iMouse.xy;\n        if (iMouse.z < 0.5)\n        {\n            mou = vec2(sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3),(1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3));\n            mou = (mou+1.0) * res;\n        }\n        vec2 z = ((-res+2.0 * gl_FragCoord.xy) / res.y);\n        vec2 p = ((-res+2.0+mou) / res.y);\n        for( int i = 0; i < 20; i++) \n        {\n            float d = dot(z,z);\n            z = (vec2( z.x, -z.y ) / d) + p; \n            z.x =  abs(z.x);\n            f = max( f, (dot(z-p,z-p) ));\n            g = min( g, sin(dot(z+p,z+p))+1.0);\n        }\n        f = abs(-log(f) / 3.5);\n        g = abs(-log(g) / 8.0);\n        gl_FragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);\n    }\n",j="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",N="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    #define t iTime\n    mat2 m(float a){float c=cos(a), s=sin(a);return mat2(c,-s,s,c);}\n    float map(vec3 p){\n        p.xz*= m(t*0.4);p.xy*= m(t*0.3);\n        vec3 q = p*2.+t;\n        return length(p+vec3(sin(t*0.7)))*log(length(p)+1.) + sin(q.x+sin(q.z+sin(q.y)))*0.5 - 1.;\n    }\n\n    void main(){\t\n        vec2 p = gl_FragCoord.xy/iResolution.y - vec2(.9,.5);\n        vec3 cl = vec3(0.);\n        float d = 2.5;\n        for(int i=0; i<=5; i++)\t{\n            vec3 p = vec3(0,0,5.) + normalize(vec3(p, -1.))*d;\n            float rz = map(p);\n            float f =  clamp((rz - map(p+.1))*0.5, -.1, 1. );\n            vec3 l = vec3(0.1,0.3,.4) + vec3(5., 2.5, 3.)*f;\n            cl = cl*l + smoothstep(2.5, .0, rz)*.7*l;\n            d += min(rz, 1.);\n        }\n        gl_FragColor = vec4(cl, 1.);\n    }\n",L="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",G="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    uniform vec4 iMouse; //mouse pixel coords. xy:current(if MLB down),zw:click\n    vec3 drawCircle(vec2 pos, float radius, float width, float power, vec4 color)\n    {\n        vec2 mousePos = iMouse.xy - vec2(0.5);\n        float dist1 = length(pos);\n        dist1 = fract((dist1 * 5.0) - fract(iTime));\n        float dist2 = dist1 - radius;\n        float intensity = pow(radius / abs(dist2), width); \n        vec3 col = color.rgb * intensity * power * max((0.8- abs(dist2)), 0.0);\n        return col;\n    }\n\n    vec3 hsv2rgb(float h, float s, float v)\n    {\n        vec4 t = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n        vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n        return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n    }\n\n    void main()\n    {\n        // // -1.0 ~ 1.0\n        vec2 pos = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        \n        float h = mix(0.5, 0.65, length(pos));\n        vec4 color = vec4(hsv2rgb(h, 1.0, 1.0), 1.0);\n        float radius = 0.5;\n        float width = 0.8;\n        float power = 0.1;\n        vec3 finalColor = drawCircle(pos, radius, width, power, color);\n\n        pos = abs(pos);\n        // vec3 finalColor = vec3(pos.x, 0.0, pos.y);\n\n        gl_FragColor = vec4(finalColor, 1.0);\n    }\n",V="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",q="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    #define SHAPE_3D 1\n\n    float time = 0.0;\n\n    mat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);  \n    }\n\n    float rnd(float t) {\n    \n    return fract(sin(t*425.512)*742.712);\n    }\n\n    float curve(float t, float d) {\n    t/=d;\n    return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0));\n    }\n\n    float box(vec3 p, vec3 s) {\n    p=abs(p)-s;\n    return max(p.x, max(p.y,p.z));\n    }\n\n    float map(vec3 p) {\n    \n    float t=time*.3 + curve(time, .7)*5.0;\n    p.xz *= rot(t);\n    p.yz *= rot(t*.3);\n    \n    p = abs(p)-curve(time, .21)*5.0;\n    p = abs(p)-curve(time, .32)*2.0;\n    \n    float d = box(p, vec3(1.0+curve(time, .1)));\n    \n    vec3 p2 = p;\n    float t2 = time;\n    p2.xy *= rot(t2);\n    p2.zy *= rot(t2*1.3);\n    p2 = abs(p2)-curve(time,.4)*3.0;\n    d = min(d, length(p2.xz)-.2);\n    \n    return d;\n    }\n\n    void main()\n    {\n    // slowed down the time because there is no music to pump it up\n    time = mod(iTime*0.3, 300.0);\n        \n    vec2 uv = vec2(gl_FragCoord.x / iResolution.x, gl_FragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 col=vec3(0);\n    \n        \n    #if SHAPE_3D\n    vec3 s=vec3(0,0,-20);\n    vec3 r=normalize(vec3(-uv,1));\n    vec3 p=s;\n    for(int i=0; i<100; ++i) {\n        float d=map(p);\n        if(d<0.001) {\n        uv += map(p+r)*.14;\n        break;\n        }\n        if(d>100.0) {\n        break;\n        }\n        p+=r*d;\n    }\n    \n    col += 0.1/(0.1+abs(map(p+r)));\n    #endif\n    \n    bool stop = rnd(floor(time*1.0+.3))>0.3;\n    float ss = 10.0 + floor(pow(curve(time, 3.0),20.0)*100.0);\n    //if(!stop) uv.x += sin(abs(uv.x+sin(time))+sin(uv.y*10+time)*0.1)*.3;\n    float off = floor(uv.x*ss)/ss;\n    if(stop) off=0.0;\n    \n    uv.y -= pow(curve(time+rnd(off+.1), .3),4.0)*.3;\n    uv.x -= (curve(time+rnd(off), .4)-.5)*.1;\n    \n    \n    \n    \n    for(float i=0.0; i<30.0; ++i) {\n        \n        vec2 p = uv;\n        float t = time*.7;\n        float t2 = curve(time + i, 0.7)*3.0;\n        p *= rot(t+i*.2 + sin(t + i));\n        p.x-=sin(t2 + i*7.3)*0.3;\n        p.x += pow(curve(time, .7),4.0)*.7-.3;\n        \n        col += vec3(1,0.7-sin(i*3.7)*.3,0.8-sin(i))*0.002*exp(-fract(time+i*.1))/(0.003+abs(p.x));\n        col += 0.001/(0.003+abs(length(p)-.3));\n    }\n    \n    col *= 0.7+curve(time,.2)*.3;\n    col = smoothstep(0.0,1.0,col);\n    col = pow(col, vec3(curve(time*10.0 - length(uv)*10.0,1.0)*3.0+1.0));\n    \n    gl_FragColor = vec4(col, 1);\n    }\n",B="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",U="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    uniform vec4 iMouse;\n\n    precision highp float;\n\n\n    float gTime = 0.;\n    const float REPEAT = 5.0;\n\n    // 回転行列\n    mat2 rot(float a) {\n        float c = cos(a), s = sin(a);\n        return mat2(c,s,-s,c);\n    }\n\n    float sdBox( vec3 p, vec3 b )\n    {\n        vec3 q = abs(p) - b;\n        return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n    }\n\n    float box(vec3 pos, float scale) {\n        pos *= scale;\n        float base = sdBox(pos, vec3(.4,.4,.1)) /1.5;\n        pos.xy *= 5.;\n        pos.y -= 3.5;\n        pos.xy *= rot(.75);\n        float result = -base;\n        return result;\n    }\n\n    float box_set(vec3 pos, float iTime) {\n        vec3 pos_origin = pos;\n        pos = pos_origin;\n        pos .y += sin(gTime * 0.4) * 2.5;\n        pos.xy *=   rot(.8);\n        float box1 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n        pos = pos_origin;\n        pos .y -=sin(gTime * 0.4) * 2.5;\n        pos.xy *=   rot(.8);\n        float box2 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\n        pos = pos_origin;\n        pos .x +=sin(gTime * 0.4) * 2.5;\n        pos.xy *=   rot(.8);\n        float box3 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n        pos = pos_origin;\n        pos .x -=sin(gTime * 0.4) * 2.5;\n        pos.xy *=   rot(.8);\n        float box4 = box(pos,2. - abs(sin(gTime * 0.4)) * 1.5);\t\n        pos = pos_origin;\n        pos.xy *=   rot(.8);\n        float box5 = box(pos,.5) * 6.;\t\n        pos = pos_origin;\n        float box6 = box(pos,.5) * 6.;\t\n        float result = max(max(max(max(max(box1,box2),box3),box4),box5),box6);\n        return result;\n    }\n\n    float map(vec3 pos, float iTime) {\n        vec3 pos_origin = pos;\n        float box_set1 = box_set(pos, iTime);\n\n        return box_set1;\n    }\n\n\n    void main() {\n        vec2 p = (gl_FragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n        vec3 ro = vec3(0., -0.2 ,iTime * 4.);\n        vec3 ray = normalize(vec3(p, 1.5));\n        ray.xy = ray.xy * rot(sin(iTime * .03) * 5.);\n        ray.yz = ray.yz * rot(sin(iTime * .05) * .2);\n        float t = 0.1;\n        vec3 col = vec3(0.);\n        float ac = 0.0;\n\n\n        for (int i = 0; i < 99; i++){\n            vec3 pos = ro + ray * t;\n            pos = mod(pos-2., 4.) -2.;\n            gTime = iTime -float(i) * 0.01;\n            \n            float d = map(pos, iTime);\n\n            d = max(abs(d), 0.01);\n            ac += exp(-d*23.);\n\n            t += d* 0.55;\n        }\n\n        col = vec3(ac * 0.02);\n\n        col +=vec3(0.,0.2 * abs(sin(iTime)),0.5 + sin(iTime) * 0.2);\n\n\n        gl_FragColor = vec4(col ,1.0 - t * (0.02 + 0.02 * sin (iTime)));\n    }\n",X="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",Z="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    #define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n    #define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n    #define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n    #define M_PI 3.1415926535897932384626433832795\n\n    #define blue1 vec3(0.74,0.95,1.00)\n    #define blue2 vec3(0.87,0.98,1.00)\n    #define blue3 vec3(0.35,0.76,0.83)\n    #define blue4 vec3(0.953,0.969,0.89)\n    #define red   vec3(1.00,0.38,0.227)\n\n    #define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\n    float movingLine(vec2 uv, vec2 center, float radius)\n    {\n        //angle of the line\n        float theta0 = 90.0 * iTime;\n        vec2 d = uv - center;\n        float r = sqrt( dot( d, d ) );\n        if(r<radius)\n        {\n            //compute the distance to the line theta=theta0\n            vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                                -sin(theta0*M_PI/180.0));\n            float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n            d = normalize(d);\n            //compute gradient based on angle difference to theta0\n            float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n            float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n            return SMOOTH(l,1.0)+0.5*gradient;\n        }\n        else return 0.0;\n    }\n\n    float circle(vec2 uv, vec2 center, float radius, float width)\n    {\n        float r = length(uv - center);\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    }\n\n    float circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n    {\n        vec2 d = uv - center;\n        float r = sqrt( dot( d, d ) );\n        d = normalize(d);\n        if( abs(d.y) > opening )\n            return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n        else\n            return 0.0;\n    }\n    float circle3(vec2 uv, vec2 center, float radius, float width)\n    {\n        vec2 d = uv - center;\n        float r = sqrt( dot( d, d ) );\n        d = normalize(d);\n        float theta = 180.0*(atan(d.y,d.x)/M_PI);\n        return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n            mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n            (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n    }\n\n    float triangles(vec2 uv, vec2 center, float radius)\n    {\n        vec2 d = uv - center;\n        return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n            + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n            + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n            + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n    }\n\n    float _cross(vec2 uv, vec2 center, float radius)\n    {\n        vec2 d = uv - center;\n        int x = int(d.x);\n        int y = int(d.y);\n        float r = sqrt( dot( d, d ) );\n        if( (r<radius) && ( (x==y) || (x==-y) ) )\n            return 1.0;\n        else return 0.0;\n    }\n    float dots(vec2 uv, vec2 center, float radius)\n    {\n        vec2 d = uv - center;\n        float r = sqrt( dot( d, d ) );\n        if( r <= 2.5 )\n            return 1.0;\n        if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n            return 1.0;\n        else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n            return 0.5;\n        else\n            return 0.0;\n    }\n    float bip1(vec2 uv, vec2 center)\n    {\n        return SMOOTH(length(uv - center),3.0);\n    }\n    float bip2(vec2 uv, vec2 center)\n    {\n        float r = length(uv - center);\n        float R = 8.0+mod(87.0*iTime, 80.0);\n        return (0.5-0.5*cos(30.0*iTime)) * SMOOTH(r,5.0)\n            + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n            + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n    }\n    void main()\n    {\n        vec3 finalColor;\n        vec2 uv = gl_FragCoord.xy;\n        //center of the image\n        vec2 c = iResolution.xy/2.0;\n        finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n        finalColor += ( circle(uv, c, 100.0, 1.0)\n                    + circle(uv, c, 165.0, 1.0) ) * blue1;\n        finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n        finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n        finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n        finalColor += movingLine(uv, c, 240.0) * blue3;\n        finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n        finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(iTime)) * blue3;\n        if( length(uv-c) < 240.0 )\n        {\n            //animate some bips with random movements\n            vec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*iTime);\n            finalColor += bip1(uv, c+p) * vec3(1,1,1);\n            p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*iTime)+0.15*iTime);\n            finalColor += bip1(uv, c+p) * vec3(1,1,1);\n            p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*iTime+7.0)+0.2*iTime);\n            finalColor += bip2(uv,c+p) * red;\n        }\n\n        gl_FragColor = vec4( finalColor, 1.0 );\n    }\n",W="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",K="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    float noise(vec3 p) //Thx to Las^Mercury\n    {\n        vec3 i = floor(p);\n        vec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n        vec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n        a = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n        a.xy = mix(a.xz, a.yw, f.y);\n        return mix(a.x, a.y, f.z);\n    }\n\n    float sphere(vec3 p, vec4 spr)\n    {\n        return length(spr.xyz-p) - spr.w;\n    }\n\n    float flame(vec3 p)\n    {\n        float d = sphere(p*vec3(1.,.5,1.), vec4(.0,-1.,.0,1.));\n        return d + (noise(p+vec3(.0,iTime*2.,.0)) + noise(p*3.)*.5)*.25*(p.y) ;\n    }\n\n    float scene(vec3 p)\n    {\n        return min(100.-length(p) , abs(flame(p)) );\n    }\n\n    vec4 raymarch(vec3 org, vec3 dir)\n    {\n        float d = 0.0, glow = 0.0, eps = 0.02;\n        vec3  p = org;\n        bool glowed = false;\n        \n        for(int i=0; i<64; i++)\n        {\n            d = scene(p) + eps;\n            p += d * dir;\n            if( d>eps )\n            {\n                if(flame(p) < .0)\n                    glowed=true;\n                if(glowed)\n                    glow = float(i)/64.;\n            }\n        }\n        return vec4(p,glow);\n    }\n\n    void main()\n    {\n        vec2 v = -1.0 + 2.0 * gl_FragCoord.xy / iResolution.xy;\n        v.x *= iResolution.x/iResolution.y;\n        \n        vec3 org = vec3(0., -2., 4.);\n        vec3 dir = normalize(vec3(v.x*1.6, -v.y, -1.5));\n        \n        vec4 p = raymarch(org, dir);\n        float glow = p.w;\n        \n        vec4 col = mix(vec4(1.,.5,.1,1.), vec4(0.1,.5,1.,1.), p.y*.02+.4);\n        \n        gl_FragColor = mix(vec4(0.), col, pow(glow*2.,4.));\n        //gl_FragColor = mix(vec4(1.), mix(vec4(1.,.5,.1,1.),vec4(0.1,.5,1.,1.),p.y*.02+.4), pow(glow*2.,4.));\n\n    }\n",Y="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",J="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    \n    #define TAU 6.28318530718\n    #define MAX_ITER 5\n\n    void main() \n    {\n        float time = iTime * .5+23.0;\n        // uv should be the 0-1 uv of texture...\n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        \n    #ifdef SHOW_TILING\n        vec2 p = mod(uv*TAU*2.0, TAU)-250.0;\n    #else\n        vec2 p = mod(uv*TAU, TAU)-250.0;\n    #endif\n        vec2 i = vec2(p);\n        float c = 1.0;\n        float inten = .005;\n\n        for (int n = 0; n < MAX_ITER; n++) \n        {\n            float t = time * (1.0 - (3.5 / float(n+1)));\n            i = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n            c += 1.0/length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n        }\n        c /= float(MAX_ITER);\n        c = 1.17-pow(c, 1.4);\n        vec3 colour = vec3(pow(abs(c), 8.0));\n        colour = clamp(colour + vec3(0.0, 0.35, 0.5), 0.0, 1.0);\n        \n\n        #ifdef SHOW_TILING\n        // Flash tile borders...\n        vec2 pixel = 2.0 / iResolution.xy;\n        uv *= 2.0;\n\n        float f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n        vec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n        uv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n        colour = mix(colour, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n        \n        #endif\n        gl_FragColor = vec4(colour, 1.0);\n    }\n",Q="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",$="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    void main()\n    {\n        vec2 uv = (gl_FragCoord.xy / iResolution.xy) - .5;\n        float t = iTime * .1 + ((.25 + .05 * sin(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n        float si = sin(t);\n        float co = cos(t);\n        mat2 ma = mat2(co, si, -si, co);\n\n        float v1, v2, v3;\n        v1 = v2 = v3 = 0.0;\n        \n        float s = 0.0;\n        for (int i = 0; i < 100; i++)\n        {\n            vec3 p = s * vec3(uv, 0.0);\n            p.xy *= ma;\n            p += vec3(.22, .3, s - 1.5 - sin(iTime * .13) * .1);\n            for (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) - 0.659;\n            v1 += dot(p,p) * .0015 * (1.8 + sin(length(uv.xy * 13.0) + .5  - iTime * .2));\n            v2 += dot(p,p) * .0013 * (1.5 + sin(length(uv.xy * 14.5) + 1.2 - iTime * .3));\n            v3 += length(p.xy*10.) * .0003;\n            s  += .035;\n        }\n        \n        float len = length(uv);\n        v1 *= smoothstep(.7, .0, len);\n        v2 *= smoothstep(.5, .0, len);\n        v3 *= smoothstep(.9, .0, len);\n        \n        vec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n                        (v1 + v3) * .3,\n                        v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\n        gl_FragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n    }\n",nn="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",en="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    uniform vec4 iMouse; //shader playback time (in seconds)\n#define MODEL_ROTATION vec2(.3, .25)\n#define CAMERA_ROTATION vec2(.5, .5)\n\n// 0: Defaults\n// 1: Model\n// 2: Camera\n#define MOUSE_CONTROL 1\n\n//#define DEBUG\n\n// 1, 2, or 3\n//#define LOOP 1\n\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n    float t = dot(p, planeNormal)+offset;\n    if (t < 0.) {\n        p = p - (2.*t)*planeNormal;\n    }\n    return sign(t);\n}\n\nfloat smax(float a, float b, float r) {\n    float m = max(a, b);\n    if ((-a < r) && (-b < r)) {\n        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n    } else {\n        return m;\n    }\n}\n\n\n// --------------------------------------------------------\n// Icosahedron domain mirroring\n// Adapted from knighty https://www.shadertoy.com/view/MsKGzw\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec3 facePlane;\nvec3 uPlane;\nvec3 vPlane;\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid initIcosahedron() {//setup folding planes and vertex\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n    pbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc); pca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :)\n\tpab=vec3(0,0,1);\n    \n    facePlane = pca;\n    uPlane = cross(vec3(1,0,0), facePlane);\n    vPlane = vec3(1,0,0);\n}\n\nvoid pModIcosahedron(inout vec3 p) {\n    p = abs(p);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n    p.xy = abs(p.xy);\n    pReflect(p, nc, 0.);\n}\n\n\n// --------------------------------------------------------\n// Triangle tiling\n// Adapted from mattz https://www.shadertoy.com/view/4d2GzV\n// --------------------------------------------------------\n\nconst float sqrt3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 cart2hex = mat2(1, 0, i3, 2. * i3);\nconst mat2 hex2cart = mat2(1, 0, -.5, .5 * sqrt3);\n\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nstruct TriPoints {\n\tvec2 a;\n    vec2 b;\n    vec2 c;\n    vec2 center;\n    vec2 ab;\n    vec2 bc;\n    vec2 ca;\n};\n\nTriPoints closestTriPoints(vec2 p) {    \n    vec2 pTri = cart2hex * p;\n    vec2 pi = floor(pTri);\n    vec2 pf = fract(pTri);\n    \n    float split1 = step(pf.y, pf.x);\n    float split2 = step(pf.x, pf.y);\n    \n    vec2 a = vec2(split1, 1);\n    vec2 b = vec2(1, split2);\n    vec2 c = vec2(0, 0);\n\n    a += pi;\n    b += pi;\n    c += pi;\n\n    a = hex2cart * a;\n    b = hex2cart * b;\n    c = hex2cart * c;\n    \n    vec2 center = (a + b + c) / 3.;\n    \n\tvec2 ab = (a + b) / 2.;\n    vec2 bc = (b + c) / 2.;\n    vec2 ca = (c + a) / 2.;\n\n    return TriPoints(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Geodesic tiling\n// --------------------------------------------------------\n\nstruct TriPoints3D {\n\tvec3 a;\n    vec3 b;\n    vec3 c;\n\tvec3 center;\n    vec3 ab;\n    vec3 bc;\n    vec3 ca;\n};\n\nvec3 intersection(vec3 n, vec3 planeNormal, float planeOffset) {\n    float denominator = dot(planeNormal, n);\n    float t = (dot(vec3(0), planeNormal ) + planeOffset) / -denominator;\n    return n * t;\n}\n\n//// Edge length of an icosahedron with an inscribed sphere of radius of 1\n//float edgeLength = 1. / ((sqrt(3.) / 12.) * (3. + sqrt(5.)));\n//// Inner radius of the icosahedron's face\n//float faceRadius = (1./6.) * sqrt(3.) * edgeLength;\nfloat faceRadius = 0.3819660112501051;\n\n// 2D coordinates on the icosahedron face\nvec2 icosahedronFaceCoordinates(vec3 p) {\n    vec3 pn = normalize(p);\n    vec3 i = intersection(pn, facePlane, -1.);\n    return vec2(dot(i, uPlane), dot(i, vPlane));\n}\n\n// Project 2D icosahedron face coordinates onto a sphere\nvec3 faceToSphere(vec2 facePoint) {\n\treturn normalize(facePlane + (uPlane * facePoint.x) + (vPlane * facePoint.y));\n}\n\nTriPoints3D geodesicTriPoints(vec3 p, float subdivisions) {\n    // Get 2D cartesian coordiantes on that face\n    vec2 uv = icosahedronFaceCoordinates(p);\n    \n    // Get points on the nearest triangle tile\n\tfloat uvScale = subdivisions / faceRadius / 2.;\n    TriPoints points = closestTriPoints(uv * uvScale);\n    \n    // Project 2D triangle coordinates onto a sphere \n    vec3 a = faceToSphere(points.a / uvScale);\n    vec3 b = faceToSphere(points.b / uvScale);\n    vec3 c = faceToSphere(points.c / uvScale);\n    vec3 center = faceToSphere(points.center / uvScale);\n    vec3 ab = faceToSphere(points.ab / uvScale);\n    vec3 bc = faceToSphere(points.bc / uvScale);\n    vec3 ca = faceToSphere(points.ca / uvScale);\n    \n    return TriPoints3D(a, b, c, center, ab, bc, ca);\n}\n\n\n// --------------------------------------------------------\n// Spectrum colour palette\n// IQ https://www.shadertoy.com/view/ll2GD3\n// --------------------------------------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n// --------------------------------------------------------\n// Model/Camera Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .5) * PI;\n    ry = (-xy.x) * 2. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Animation \n// --------------------------------------------------------\n\nconst float SCENE_DURATION = 6.;\nconst float CROSSFADE_DURATION = 2.;\n\nfloat time;\n\nstruct HexSpec {\n    float roundTop;\n    float roundCorner;\n\tfloat height;\n    float thickness;\n    float gap;    \n};\n    \nHexSpec newHexSpec(float subdivisions) {\n\treturn HexSpec(\n        .05 / subdivisions,\n        .1 / subdivisions,\n        2.,\n        2.,\n        .005\n    );\n}\n    \n// Animation 1\n    \nfloat animSubdivisions1() {\n\treturn mix(2.4, 3.4, cos(time * PI) * .5 + .5);\n}\n\nHexSpec animHex1(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float offset = time * 3. * PI;\n    offset -= subdivisions;\n    float blend = dot(hexCenter, pca);\n    blend = cos(blend * 30. + offset) * .5 + .5;\n    spec.height = mix(1.75, 2., blend);\n\n    spec.thickness = spec.height;\n\n    return spec;\n}\n\n// Animation 2\n\nfloat animSubdivisions2() {\n    return mix(1., 2.3, sin(time * PI/2.) * .5 + .5);\n}\n\nHexSpec animHex2(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = hexCenter.y;\n    spec.height = mix(1.6, 2., sin(blend * 10. + time * PI) * .5 + .5);\n    \n    spec.roundTop = .02 / subdivisions;\n    spec.roundCorner = .09 / subdivisions;\n    spec.thickness = spec.roundTop * 4.;\n    spec.gap = .01;\n\n    return spec;\n}\n\n// Animation 3\n\nfloat animSubdivisions3() {\n\treturn 5.;\n}\n\nHexSpec animHex3(vec3 hexCenter, float subdivisions) {\n    HexSpec spec = newHexSpec(subdivisions);\n    \n    float blend = acos(dot(hexCenter, pab)) * 10.;\n    blend = cos(blend + time * PI) * .5 + .5;\n    spec.gap = mix(.01, .4, blend) / subdivisions;\n\n    spec.thickness = spec.roundTop * 2.;\n\n\treturn spec;\n}\n\n// Transition between animations\n\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\nfloat transitionValues(float a, float b, float c) {\n    #ifdef LOOP\n        #if LOOP == 1\n            return a;\n        #endif\n        #if LOOP == 2\n            return b;\n        #endif\n        #if LOOP == 3\n            return c;\n        #endif\n    #endif\n    float t = time / SCENE_DURATION;\n    float scene = floor(mod(t, 3.));\n    float blend = fract(t);\n    float delay = (SCENE_DURATION - CROSSFADE_DURATION) / SCENE_DURATION;\n    blend = max(blend - delay, 0.) / (1. - delay);\n    blend = sineInOut(blend);\n    float ab = mix(a, b, blend);\n    float bc = mix(b, c, blend);\n    float cd = mix(c, a, blend);\n    float result = mix(ab, bc, min(scene, 1.));\n    result = mix(result, cd, max(scene - 1., 0.));\n    return result;\n}\n \nHexSpec transitionHexSpecs(HexSpec a, HexSpec b, HexSpec c) {\n    float roundTop = transitionValues(a.roundTop, b.roundTop, c.roundTop);\n    float roundCorner = transitionValues(a.roundCorner, b.roundCorner, c.roundCorner);\n\tfloat height = transitionValues(a.height, b.height, c.height);\n    float thickness = transitionValues(a.thickness, b.thickness, c.thickness);\n    float gap = transitionValues(a.gap, b.gap, c.gap);\n\treturn HexSpec(roundTop, roundCorner, height, thickness, gap);\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nconst vec3 FACE_COLOR = vec3(.9,.9,1.);\nconst vec3 BACK_COLOR = vec3(.1,.1,.15);\nconst vec3 BACKGROUND_COLOR = vec3(.0, .005, .03);\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    float glow;\n};\n\nModel hexModel(\n    vec3 p,\n    vec3 hexCenter,\n    vec3 edgeA,\n    vec3 edgeB,\n    HexSpec spec\n) {\n    float d;\n\n    float edgeADist = dot(p, edgeA) + spec.gap;\n    float edgeBDist = dot(p, edgeB) - spec.gap;\n    float edgeDist = smax(edgeADist, -edgeBDist, spec.roundCorner);\n\n    float outerDist = length(p) - spec.height;\n    d = smax(edgeDist, outerDist, spec.roundTop);\n\n    float innerDist = length(p) - spec.height + spec.thickness;\n    d = smax(d, -innerDist, spec.roundTop);\n    \n    vec3 color;\n\n    float faceBlend = (spec.height - length(p)) / spec.thickness;\n    faceBlend = clamp(faceBlend, 0., 1.);\n    color = mix(FACE_COLOR, BACK_COLOR, step(.5, faceBlend));\n    \n    vec3 edgeColor = spectrum(dot(hexCenter, pca) * 5. + length(p) + .8);    \n\tfloat edgeBlend = smoothstep(-.04, -.005, edgeDist);\n    color = mix(color, edgeColor, edgeBlend); \n\n    return Model(d, color, edgeBlend);\n}\n\n// checks to see which intersection is closer\nModel opU( Model m1, Model m2 ){\n    if (m1.dist < m2.dist) {\n        return m1;\n    } else {\n        return m2;\n    }\n}\n\nModel geodesicModel(vec3 p) {\n\n    pModIcosahedron(p);\n    \n    float subdivisions = transitionValues(\n        animSubdivisions1(),\n        animSubdivisions2(),\n        animSubdivisions3()\n   \t);\n\tTriPoints3D points = geodesicTriPoints(p, subdivisions);\n        \n\tvec3 edgeAB = normalize(cross(points.center, points.ab));\n\tvec3 edgeBC = normalize(cross(points.center, points.bc));\n    vec3 edgeCA = normalize(cross(points.center, points.ca));\n    \n    Model model, part;\n    HexSpec spec;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.b, subdivisions),\n        animHex2(points.b, subdivisions),\n        animHex3(points.b, subdivisions)\n    );\n    part = hexModel(p, points.b, edgeAB, edgeBC, spec);\n    model = part;\n\n\tspec = transitionHexSpecs(\n        animHex1(points.c, subdivisions),\n        animHex2(points.c, subdivisions),\n        animHex3(points.c, subdivisions)\n    );\n    part = hexModel(p, points.c, edgeBC, edgeCA, spec);\n    model = opU(model, part);\n    \n\tspec = transitionHexSpecs(\n        animHex1(points.a, subdivisions),\n        animHex2(points.a, subdivisions),\n        animHex3(points.a, subdivisions)\n    );\n    part = hexModel(p, points.a, edgeCA, edgeAB, spec);\n    model = opU(model, part);\n    \n\treturn model;\n}\n\nModel map( vec3 p ){\n    mat3 m = modelRotation();\n    p *= m;  \n    #ifndef LOOP\n    \tpR(p.xz, time * PI/16.);\n    #endif\n    Model model = geodesicModel(p);\n    return model;\n}\n\n// --------------------------------------------------------\n// LIGHTING\n// Adapted from IQ https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nvec3 doLighting(Model model, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = normalize(vec3(.5,.5,-1.));\n    vec3 backLightPos = normalize(vec3(-.5,-.3,1));\n    vec3 ambientPos = vec3(0,1,0);\n    \n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 1.) / 2., 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 1.), 1.5);\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(.9);\n    lin += 0.80 * amb * vec3(.5, .7, .8);\n    lin += 0.30 * bac * vec3(.25);\n    lin += 0.20 * fre * vec3(1);\n    \n    vec3 albedo = model.albedo;\n    vec3 col = mix(albedo * lin, albedo, model.glow);    \n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from cabbibo https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 8.; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = .9; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n    \n    vec3 color = BACKGROUND_COLOR;\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    vec3 ref = reflect(hit.ray.direction, hit.normal);\n\n    #ifdef DEBUG\n        color = hit.normal * 0.5 + 0.5;\n    #else \n        color = doLighting(\n            hit.model,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\nvec3 render(Hit hit){\n    shadeSurface(hit);\n\treturn hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 5.5;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 2.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 1.0 / GAMMA);\n}\n\nvoid main()\n{\n    time = iTime;\n\n    #ifdef LOOP\n        #if LOOP == 1\n            time = mod(time, 2.);   \n        #endif\n        #if LOOP == 2\n            time = mod(time, 4.);   \n        #endif\n        #if LOOP == 3\n            time = mod(time, 2.);\n    \t#endif\n    #endif\n    \n    initIcosahedron();\n    \n    vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 2.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    Hit hit = raymarch(CastRay(camPos, rd));\n\n    vec3 color = render(hit);\n    \n    #ifndef DEBUG\n        color = linearToScreen(color);\n    #endif\n\n    gl_FragColor = vec4(color,1.0);\n}\n",tn="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",on="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n\n    struct Ray {\n        vec3 origin;\n        vec3 direction;\n    };\n\n    struct Light {\n        vec3 color;\n        vec3 direction;\n    };\n\n    struct Material {\n        vec3 color;\n        float diffuse;\n        float specular;\n    };\n\n    struct Intersect {\n        float len;\n        vec3 normal;\n        Material material;\n    };\n\n    struct Sphere {\n        float radius;\n        vec3 position;\n        Material material;\n    };\n\n    struct Plane {\n        vec3 normal;\n        Material material;\n    };\n\n    const float epsilon = 1e-3;\n\n    const int iterations = 16;\n\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n    const vec3 ambient = vec3(0.6, 0.8, 1.0) * intensity / gamma;\n\n    Light light = Light(vec3(1.0) * intensity, normalize(vec3(-1.0, 0.75, 1.0)));\n\n    const Intersect miss = Intersect(0.0, vec3(0.0), Material(vec3(0.0), 0.0, 0.0));\n\n    Intersect intersect(Ray ray, Sphere sphere) {\n        vec3 oc = sphere.position - ray.origin;\n        float l = dot(ray.direction, oc);\n        float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.radius, 2.0);\n        if (det < 0.0) return miss;\n\n        // Find the Closer of Two Solutions\n                float len = l - sqrt(det);\n        if (len < 0.0) len = l + sqrt(det);\n        if (len < 0.0) return miss;\n        return Intersect(len, (ray.origin + len*ray.direction - sphere.position) / sphere.radius, sphere.material);\n    }\n\n    Intersect intersect(Ray ray, Plane plane) {\n        float len = -dot(ray.origin, plane.normal) / dot(ray.direction, plane.normal);\n        if (len < 0.0) return miss;\n        return Intersect(len, plane.normal, plane.material);\n    }\n\n    Intersect trace(Ray ray) {\n        const int num_spheres = 3;\n        Sphere spheres[num_spheres];\n\n        spheres[0] = Sphere(2.0, vec3(-4.0, 3.0 + sin(iTime), 0), Material(vec3(1.0, 0.0, 0.2), 1.0, 0.001));\n        spheres[1] = Sphere(3.0, vec3( 4.0 + cos(iTime), 3.0, 0), Material(vec3(0.0, 0.2, 1.0), 1.0, 0.0));\n        spheres[2] = Sphere(1.0, vec3( 0.5, 1.0, 6.0),                  Material(vec3(1.0, 1.0, 1.0), 0.5, 0.25));\n\n        Intersect intersection = miss;\n        Intersect plane = intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n        if (plane.material.diffuse > 0.0 || plane.material.specular > 0.0) { intersection = plane; }\n        for (int i = 0; i < num_spheres; i++) {\n            Intersect sphere = intersect(ray, spheres[i]);\n            if (sphere.material.diffuse > 0.0 || sphere.material.specular > 0.0)\n                intersection = sphere;\n        }\n        return intersection;\n    }\n\n    vec3 radiance(Ray ray) {\n        vec3 color = vec3(0.0), fresnel = vec3(0.0);\n        vec3 mask = vec3(1.0);\n        for (int i = 0; i <= iterations; ++i) {\n            Intersect hit = trace(ray);\n\n            if (hit.material.diffuse > 0.0 || hit.material.specular > 0.0) {\n\n                vec3 r0 = hit.material.color.rgb * hit.material.specular;\n                float hv = clamp(dot(hit.normal, -ray.direction), 0.0, 1.0);\n                fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n                mask *= fresnel;\n\n                if (trace(Ray(ray.origin + hit.len * ray.direction + epsilon * light.direction, light.direction)) == miss) {\n                    color += clamp(dot(hit.normal, light.direction), 0.0, 1.0) * light.color\n                        * hit.material.color.rgb * hit.material.diffuse\n                        * (1.0 - fresnel) * mask / fresnel;\n                }\n\n                vec3 reflection = reflect(ray.direction, hit.normal);\n                ray = Ray(ray.origin + hit.len * ray.direction + epsilon * reflection, reflection);\n\n            } else {\n\n                vec3 spotlight = vec3(1e6) * pow(abs(dot(ray.direction, light.direction)), 250.0);\n                color += mask * (ambient + spotlight); break;\n            }\n        }\n        return color;\n    }\n\n    void main() {\n        vec2 uv    = gl_FragCoord.xy / iResolution.xy - vec2(0.5);\n            uv.x *= iResolution.x / iResolution.y;\n\n        Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n        gl_FragColor = vec4(pow(radiance(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n    }\n",rn="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",an="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n\n    #define SHADOW\n    #define REFLECTION\n\n    #define RAYCASTSTEPS 40\n\n    #define EPSILON 0.0001\n    #define MAXDISTANCE 400.\n    #define GRIDSIZE 8.\n    #define GRIDSIZESMALL 5.\n    #define MAXHEIGHT 30.\n    #define SPEED 0.5\n\n    #define time iTime\n\n    //\n    // math functions\n    //\n\n    const mat2 mr = mat2 (0.84147,  0.54030,\n                        0.54030, -0.84147 );\n    float hash( float n ) {\n        return fract(sin(n)*43758.5453);\n    }\n    vec2 hash2( float n ) {\n        return fract(sin(vec2(n,n+1.0))*vec2(2.1459123,3.3490423));\n    }\n    vec2 hash2( vec2 n ) {\n        return fract(sin(vec2( n.x*n.y, n.x+n.y))*vec2(2.1459123,3.3490423));\n    }\n    vec3 hash3( float n ) {\n        return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n    }\n    vec3 hash3( vec2 n ) {\n        return fract(sin(vec3(n.x, n.y, n+2.0))*vec3(3.5453123,4.1459123,1.3490423));\n    }\n    //\n    // intersection functions\n    //\n\n    bool intersectPlane(vec3 ro, vec3 rd, float height, out float dist) {\t\n        if (rd.y==0.0) {\n            return false;\n        }\n        \n        float d = -(ro.y - height)/rd.y;\n        d = min(100000.0, d);\n        if( d > 0. ) {\n            dist = d;\n            return true;\n        }\n        return false;\n    }\n\n    bool intersectUnitSphere ( in vec3 ro, in vec3 rd, in vec3 sph, out float dist, out vec3 normal ) {\n        vec3  ds = ro - sph;\n        float bs = dot( rd, ds );\n        float cs = dot(  ds, ds ) - 1.0;\n        float ts = bs*bs - cs;\n        \n        if( ts > 0.0 ) {\n            ts = -bs - sqrt( ts );\n            if( ts>0. ) {\n                normal = normalize( (ro+ts*rd)-sph );\n                dist = ts;\n                return true;\n            }\n        }\n        \n        return false;\n    }\n\n    //\n    // Scene\n    //\n\n    void getSphereOffset( vec2 grid, inout vec2 center ) {\n        center = (hash2( grid+vec2(43.12,1.23) ) - vec2(0.5) )*(GRIDSIZESMALL);\n    }\n    void getMovingSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n        // falling?\n        float s = 0.1+hash( grid.x*1.23114+5.342+74.324231*grid.y );\n        float t = fract(14.*s + time/s*.3);\n        \n        float y =  s * MAXHEIGHT * abs( 4.*t*(1.-t) );\n        vec2 offset = grid + sphereOffset;\n        \n        center = vec3( offset.x, y, offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n    }\n    void getSpherePosition( vec2 grid, vec2 sphereOffset, inout vec3 center ) {\n        vec2 offset = grid + sphereOffset;\n        center = vec3( offset.x, 0., offset.y ) + 0.5*vec3( GRIDSIZE, 2., GRIDSIZE );\n    }\n    vec3 getSphereColor( vec2 grid ) {\n        return normalize( hash3( grid+vec2(43.12*grid.y,12.23*grid.x) ) );\n    }\n\n    vec3 trace(vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out float dist, out int material) {\n        material = 0; // sky\n        dist = MAXDISTANCE;\n        float distcheck;\n        \n        vec3 sphereCenter, col, normalcheck;\n        \n        if( intersectPlane( ro,  rd, 0., distcheck) && distcheck < MAXDISTANCE ) {\n            dist = distcheck;\n            material = 1;\n            normal = vec3( 0., 1., 0. );\n            col = vec3( 0.25 );\n        } else {\n            col = vec3( 0. );\n        }\n        \n            \n        // trace grid\n        vec3 pos = floor(ro/GRIDSIZE)*GRIDSIZE;\n        vec3 ri = 1.0/rd;\n        vec3 rs = sign(rd) * GRIDSIZE;\n        vec3 dis = (pos-ro + 0.5  * GRIDSIZE + rs*0.5) * ri;\n        vec3 mm = vec3(0.0);\n        vec2 offset;\n            \n        for( int i=0; i<RAYCASTSTEPS; i++ )\t{\n            if( material > 1 || distance( ro.xz, pos.xz ) > dist+GRIDSIZE ) break;\n            vec2 offset;\n            getSphereOffset( pos.xz, offset );\n            \n            getMovingSpherePosition( pos.xz, -offset, sphereCenter );\n            \n            if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n                dist = distcheck;\n                normal = normalcheck;\n                material = 2;\n            }\n            \n            getSpherePosition( pos.xz, offset, sphereCenter );\n            if( intersectUnitSphere( ro, rd, sphereCenter, distcheck, normalcheck ) && distcheck < dist ) {\n                dist = distcheck;\n                normal = normalcheck;\n                col = getSphereColor( offset );\n                material = 3;\n            }\n            mm = step(dis.xyz, dis.zyx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\t\t\n        }\n        \n        vec3 color = vec3( 0. );\n        if( material > 0 ) {\n            intersection = ro + rd*dist;\n            vec2 map = floor(intersection.xz/GRIDSIZE)*GRIDSIZE;\n            \n            if( material == 1 || material == 3 ) {\n                // lightning\n                vec3 c = vec3( -GRIDSIZE,0., GRIDSIZE );\n                for( int x=0; x<3; x++ ) {\n                    for( int y=0; y<3; y++ ) {\n                        vec2 mapoffset = map+vec2( c[x], c[y] );\t\t\n                        vec2 offset;\n                        getSphereOffset( mapoffset, offset );\n                        vec3 lcolor = getSphereColor( mapoffset );\n                        vec3 lpos;\n                        getMovingSpherePosition( mapoffset, -offset, lpos );\n                        \n                        float shadow = 1.;\n    #ifdef SHADOW\n                        if( material == 1 ) {\n                            for( int sx=0; sx<3; sx++ ) {\n                                for( int sy=0; sy<3; sy++ ) {\n                                    if( shadow < 1. ) continue;\n                                    \n                                    vec2 smapoffset = map+vec2( c[sx], c[sy] );\t\t\n                                    vec2 soffset;\n                                    getSphereOffset( smapoffset, soffset );\n                                    vec3 slpos, sn;\n                                    getSpherePosition( smapoffset, soffset, slpos );\n                                    float sd;\n                                    if( intersectUnitSphere( intersection, normalize( lpos - intersection ), slpos, sd, sn )  ) {\n                                        shadow = 0.;\n                                    }\t\t\t\t\t\t\t\n                                }\n                            }\n                        }\n    #endif\n                        color += col * lcolor * ( shadow * max( dot( normalize(lpos-intersection), normal ), 0.) *\n                                                clamp(10. / dot( lpos - intersection, lpos - intersection) - 0.075, 0., 1.)  );\n                    }\n                }\n            } else {\n                // emitter\n                color = (3.+2.*dot(normal, vec3( 0.5, 0.5, -0.5))) * getSphereColor( map );\n            }\n        }\n        return color;\n    }\n\n\n    void main() {\n        vec2 q = gl_FragCoord.xy/iResolution.xy;\n        vec2 p = -1.0+2.0*q;\n        p.x *= iResolution.x/iResolution.y;\n        \n        // camera\t\n        vec3 ce = vec3( cos( 0.232*time) * 10., 6.+3.*cos(0.3*time), GRIDSIZE*(time/SPEED) );\n        vec3 ro = ce;\n        vec3 ta = ro + vec3( -sin( 0.232*time) * 10., -2.0+cos(0.23*time), 10.0 );\n        \n        float roll = -0.15*sin(0.5*time);\n        \n        // camera tx\n        vec3 cw = normalize( ta-ro );\n        vec3 cp = vec3( sin(roll), cos(roll),0.0 );\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv = normalize( cross(cu,cw) );\n        vec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n        \n        // raytrace\n        int material;\n        vec3 normal, intersection;\n        float dist;\n        \n        vec3 col = trace(ro, rd, intersection, normal, dist, material);\n\n    #ifdef REFLECTION\n        if( material > 0 ) {\n            float f = 0.04 * clamp(pow(1. + dot(rd, normal), 5.), 0., 1.);\n                \n            vec3 ro = intersection + EPSILON*normal;\n            rd = reflect( rd, normal );\n            vec3 refColor = trace(ro, rd, intersection, normal, dist, material);\n            if (material > 2) { \n                col += .5 * refColor; \n            } else { // fresnell on floor\n                col += f * refColor;\n            }\n        }\n    #endif\n        \n        col = pow( col * .5, vec3(1./2.2) );\t\n        col = clamp(col, 0.0, 1.0);\n        \n        // vigneting\n        col *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n        \n        gl_FragColor = vec4( col,1.0);\n    }\n",cn="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",sn="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    uniform vec4 iMouse; \n\n    mat2 rotate2d(float angle){\n        return mat2(cos(angle),-sin(angle),\n                    sin(angle),cos(angle));\n    }\n\n    float variation(vec2 v1, vec2 v2, float strength, float speed) {\n        return sin(\n            dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n        ) / 100.0;\n    }\n\n    vec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n        \n        vec2 diff = center-uv;\n        float len = length(diff);\n\n        len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n        len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n        \n        float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n        return vec3(circle);\n    }\n\n\n    void main()\n    {\n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        uv.x *= 1.5;\n        uv.x -= 0.25;\n        \n        vec3 color;\n        float radius = 0.35;\n        vec2 center = vec2(0.5);\n        \n        \n        //paint color circle\n        color = paintCircle(uv, center, radius, 0.1);\n        \n        //color with gradient\n        vec2 v = rotate2d(iTime) * uv;\n        color *= vec3(v.x, v.y, 0.7-v.y*v.x);\n        \n        //paint white circle\n        color += paintCircle(uv, center, radius, 0.01);\n        \n        \n        gl_FragColor = vec4(color, 1.0);\n    }\n",ln="\n    void main() {\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * mvPosition;\n    }\n",dn="\n    uniform vec3 iResolution; //viewport resolution(in pixels) \n    uniform float iTime; //shader playback time (in seconds)\n    vec2 hash2(vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(123.4, 748.6)), dot(p, vec2(547.3, 659.3))))*5232.85324);   \n    }\n    float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(43.232, 75.876)))*4526.3257);   \n    }\n\n    //Based off of iq's described here: http://www.iquilezles.org/www/articles/voronoilin\n    float voronoi(vec2 p) {\n        vec2 n = floor(p);\n        vec2 f = fract(p);\n        float md = 5.0;\n        vec2 m = vec2(0.0);\n        for (int i = -1;i<=1;i++) {\n            for (int j = -1;j<=1;j++) {\n                vec2 g = vec2(i, j);\n                vec2 o = hash2(n+g);\n                o = 0.5+0.5*sin(iTime+5.038*o);\n                vec2 r = g + o - f;\n                float d = dot(r, r);\n                if (d<md) {\n                md = d;\n                m = n+g+o;\n                }\n            }\n        }\n        return md;\n    }\n\n    float ov(vec2 p) {\n        float v = 0.0;\n        float a = 0.4;\n        for (int i = 0;i<3;i++) {\n            v+= voronoi(p)*a;\n            p*=2.0;\n            a*=0.5;\n        }\n        return v;\n    }\n\n    void main()\n    {\n        vec2 uv = gl_FragCoord.xy / iResolution.xy;\n        vec4 a = vec4(0.2, 0.4, 1.0, 1.0);\n        vec4 b = vec4(0.85, 0.9, 1.0, 1.0);\n        gl_FragColor = vec4(mix(a, b, smoothstep(0.0, 0.5, ov(uv*5.0))));\n        \n    }\n",fn=function(n){Object(S["a"])(t,n);var e=Object(w["a"])(t);function t(n){var o,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2?arguments[2]:void 0;return Object(b["a"])(this,t),o=e.call(this,n,i),o.fns=r,o}return t}(A)},fa46:function(n,e,t){var o=t("abdf").f,i=t("f1a7"),r=t("7d53"),a=r("toStringTag");n.exports=function(n,e,t){n&&!i(n=t?n:n.prototype,a)&&o(n,a,{configurable:!0,value:e})}},ff89:function(n,e,t){"use strict";var o,i,r,a=t("0e39"),c=t("5b12"),s=t("f1a7"),l=t("7d53"),d=t("0e93"),f=l("iterator"),v=!1,u=function(){return this};[].keys&&(r=[].keys(),"next"in r?(i=a(a(r)),i!==Object.prototype&&(o=i)):v=!0),void 0==o&&(o={}),d||s(o,f)||c(o,f,u),n.exports={IteratorPrototype:o,BUGGY_SAFARI_ITERATORS:v}}}]);
//# sourceMappingURL=shader~subShader.4cc1b964.js.map